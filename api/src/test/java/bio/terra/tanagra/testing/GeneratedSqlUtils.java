package bio.terra.tanagra.testing;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;

import com.google.common.collect.ImmutableMap;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.nio.charset.StandardCharsets;
import java.nio.file.Path;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.apache.commons.text.StringSubstitutor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Utility class for:
 *
 * <p>- comparing the SQL generated by the API code against an expected string saved in a golden
 * file.
 *
 * <p>- overwriting the existing golden file with a new expected string.
 */
public final class GeneratedSqlUtils {
  private static final Logger LOG = LoggerFactory.getLogger(GeneratedSqlUtils.class);

  private static final Path GENERATED_SQL_FILES_PARENT_DIR =
      Path.of(System.getProperty("GRADLE_PROJECT_DIR")).resolve("src/test/resources/");

  private GeneratedSqlUtils() {}

  /**
   * - If the `generateSqlFiles` Gradle property is not set, then check the generated SQL against
   * the contents of the existing file. This is the default, most common behavior.
   *
   * <p>- If the `-PgenerateSqlFiles=true` Gradle property is set, then overwrite the existing file
   * and return. This is intended as a convenience to regenerate SQL strings when there is a code
   * change in the SQL generation logic.
   *
   * @param generatedSql SQL string generated by the current API code
   * @param fileName the name of the file in the `api/src/test/resources/aousynthetic` directory
   *     where the generated SQL to compare against during testing lives.
   */
  public static void checkMatchesOrOverwriteGoldenFile(String generatedSql, String fileName)
      throws IOException {
    LOG.info(generatedSql);
    if (System.getProperty("GENERATE_SQL_FILES") == null) {
      LOG.info("reading generated sql from file because generateSqlFiles flag is not set");
      String expectedSql = readSqlFromFile(fileName);
      assertEquals(
          expectedSql,
          generatedSql,
          "Generated SQL does not match the expected. To regenerate the golden files that contain the expected SQL, you can run `./gradlew cleanTest api:test --info -PgenerateSqlFiles=true`");
    } else {
      LOG.info("writing generated sql to file because generateSqlFiles flag is set");
      writeSqlToFile(generatedSql, fileName);
    }
  }

  /** Read the SQL string from a file. */
  private static String readSqlFromFile(String fileName) throws IOException {
    LOG.info("reading generated sql from file: {}", fileName);
    InputStream inputStream =
        GeneratedSqlUtils.class.getClassLoader().getResourceAsStream(fileName);

    InputStreamReader streamReader = new InputStreamReader(inputStream, StandardCharsets.UTF_8);
    BufferedReader reader = new BufferedReader(streamReader);
    StringBuilder fileContents = new StringBuilder();
    String line;
    while ((line = reader.readLine()) != null) {
      fileContents.append(line);
    }
    reader.close();
    return fileContents.toString();
  }

  /** Write the generated SQL string to a file. */
  private static void writeSqlToFile(String generatedSql, String fileName) throws IOException {
    Path generatedSqlFile = GENERATED_SQL_FILES_PARENT_DIR.resolve(fileName).toAbsolutePath();
    LOG.info("writing generated sql to file: {}", generatedSqlFile);
    PrintWriter writer = new PrintWriter(generatedSqlFile.toFile(), StandardCharsets.UTF_8);
    writer.println(generatedSql);
    writer.close();
  }

  /**
   * Replace the generated table aliases in the expected SQL with those in the actual SQL. The
   * purpose of this helper method is to allow a test to compare the expected and actual SQL without
   * failing on the generated alias names. This is necessary because the generated table names
   * include a randomly generated UUID, and so we will get a different alias each time.
   *
   * @param expected the expected SQL string that contains generated table aliases (e.g.
   *     sailor_boatb61b6fa5_9756_4de7_9c68_bc57fe223635)
   * @param actual the actual SQL string that contains generated table aliases (e.g.
   *     sailor_boat237e13f7_ab74_42b4_9b0c_e5a45299f942)
   * @param relationshipName the name of the relationship with the intermediate table
   * @return the expected SQL string, with its generated table aliases replaced with those in the
   *     actual SQL string
   */
  public static String replaceGeneratedIntermediateTableAliasDiffs(
      String expected, String actual, String relationshipName) {
    Pattern generatedTableAliasRegex =
        Pattern.compile(
            relationshipName
                + "[a-fA-F0-9]{8}_[a-fA-F0-9]{4}_[a-fA-F0-9]{4}_[a-fA-F0-9]{4}_[a-fA-F0-9]{12}");

    // find the generated table alias in the actual SQL
    Matcher actualAliasMatcher = generatedTableAliasRegex.matcher(actual);
    assertTrue(actualAliasMatcher.find(), "generated intermediate table alias not found");
    String actualAlias = actual.substring(actualAliasMatcher.start(), actualAliasMatcher.end());

    // replace all the generated table aliases in the expected SQL with ${generated_table_alias}
    String expectedTemplate =
        generatedTableAliasRegex.matcher(expected).replaceAll("\\$\\{generated_table_alias\\}");

    // substitute the ${generated_table_alias} in the expected SQL with the alias from the actual
    // SQL
    Map<String, String> params =
        ImmutableMap.<String, String>builder().put("generated_table_alias", actualAlias).build();
    return StringSubstitutor.replace(expectedTemplate, params);
  }
}
